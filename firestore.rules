/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for most data,
 *               with some exceptions for public read access and delivery partner data.
 *
 * Data Structure:
 * - Users: /users/{userId} - Profile data, accessible only by the user.
 * - Stores: /stores/{storeId} - Store data, write access restricted to the store owner.
 * - Products: /stores/{storeId}/products/{productId} - Product data under stores, write access restricted to the store owner.
 * - Packages: /stores/{storeId}/packages/{packageId} - Package data under stores, write access restricted to the store owner.
 * - Orders: /orders/{orderId} - Order data, accessible with validation of user and store IDs.
 * - Voice Orders: /voice-orders/{voiceOrderId} - Voice order data, accessible for now.
 * - Order Items: /orders/{orderId}/orderItems/{orderItemId} - Order item data under orders.
 * - Product Recommendations: /users/{userId}/productRecommendations/{productRecommendationId} - Recommendations for a user, accessible only by the user.
 * - Cached Recipes: /cachedRecipes/{recipeId} - Publicly readable cache of recipe ingredients.
 * - Delivery Partners: /deliveryPartners/{partnerId} - Delivery partner profile and payout settings, write access restricted to the partner.
 * - Payouts: /deliveryPartners/{partnerId}/payouts/{payoutId} - Payout history for a delivery partner, write access restricted to the partner.
 *
 * Key Security Decisions:
 * - User data is private and only accessible by the user.
 * - Store data is owned by a user, with owner-only write access.
 * - Product and Package data inherit ownership from the parent store.
 * - Orders are validated against both user and store IDs.
 * - Cached recipes are publicly readable.
 * - Delivery partner data is private, accessible only by the delivery partner, and is tied to their user ID.
 * - No user listing is allowed.
 *
 * Denormalization for Authorization:
 * - The `Order` entity denormalizes `userId` and `storeId` to allow direct authorization checks without additional reads.
 * - The `OrderItem` entity denormalizes `orderId` to allow direct authorization checks without additional reads.
 * - The `ProductRecommendation` entity denormalizes `userId` to allow direct authorization checks without additional reads.
 *
 * Structural Segregation:
 * - No explicit structural segregation is used.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data. Only the user can read or write their own data.
     * @path /users/{userId}
     * @allow (create) - User with ID 'user123' creating their own profile.
     *    request.auth.uid == 'user123' && request.resource.data.id == 'user123'
     * @allow (get, update, delete) - User with ID 'user123' reading, updating, or deleting their own profile.
     *    request.auth.uid == 'user123'
     * @deny (create) - User with ID 'user123' trying to create a profile for 'user456'.
     *    request.auth.uid == 'user123' && request.resource.data.id == 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && resource.data.id == userId;
      allow delete: if isOwner(userId) && resource.data.id == userId;
    }

    /**
     * @description Manages store data. Only the store owner can create, update, or delete store information.
     * @path /stores/{storeId}
     * @allow (create) - User with ID 'user123' creating a store and setting themself as the owner.
     *    request.auth.uid == 'user123' && request.resource.data.ownerId == 'user123'
     * @allow (get, list) - Any user can read store data.
     * @allow (update, delete) - User with ID 'user123' updating/deleting their own store with ownerId 'user123'.
     *    request.auth.uid == 'user123' && resource.data.ownerId == 'user123'
     * @deny (create) - User with ID 'user123' trying to create a store with ownerId 'user456'.
     *    request.auth.uid == 'user123' && request.resource.data.ownerId == 'user456'
     * @deny (update, delete) - User with ID 'user123' trying to update/delete a store owned by 'user456'.
     *    request.auth.uid == 'user123' && resource.data.ownerId == 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /stores/{storeId} {
      function isOwner(ownerId) {
        return request.auth.uid == ownerId;
      }
      allow get, list: if true;
      allow create: if isOwner(request.resource.data.ownerId);
      allow update: if isOwner(resource.data.ownerId) && resource != null;
      allow delete: if isOwner(resource.data.ownerId) && resource != null;
    }

    /**
     * @description Manages product data within a store. Only the store owner can create, update, or delete products.
     * @path /stores/{storeId}/products/{productId}
     * @allow (create) - User with ID 'user123' creating a product in their store 'storeXYZ' (ownerId = 'user123').
     *    get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == 'user123'
     * @allow (get, list) - Any user can read product data.
     * @allow (update, delete) - User with ID 'user123' updating/deleting a product in their store 'storeXYZ' (ownerId = 'user123').
     *    get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == 'user123'
     * @deny (create) - User with ID 'user123' creating a product in store 'storeXYZ' owned by 'user456'.
     *    get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == 'user456' && request.auth.uid == 'user123'
     * @deny (update, delete) - User with ID 'user123' updating/deleting a product in store 'storeXYZ' owned by 'user456'.
     *    get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == 'user456' && request.auth.uid == 'user123'
     * @principle Inherits ownership from the parent store.
     */
    match /stores/{storeId}/products/{productId} {
      function isStoreOwner(storeId) {
        return get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      }
      allow get, list: if true;
      allow create: if isStoreOwner(storeId);
      allow update: if isStoreOwner(storeId) && resource != null;
      allow delete: if isStoreOwner(storeId) && resource != null;
    }

     /**
     * @description Manages monthly package deals within a store. Only the store owner can create, update, or delete packages.
     * @path /stores/{storeId}/packages/{packageId}
     * @allow (create) - User with ID 'user123' creating a package in their store 'storeXYZ' (ownerId = 'user123').
     *    get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == 'user123'
     * @allow (get, list) - Any user can read package data.
     * @allow (update, delete) - User with ID 'user123' updating/deleting a package in their store 'storeXYZ' (ownerId = 'user123').
     *    get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == 'user123'
     * @deny (create) - User with ID 'user123' creating a package in store 'storeXYZ' owned by 'user456'.
     *    get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == 'user456' && request.auth.uid == 'user123'
     * @deny (update, delete) - User with ID 'user123' updating/deleting a package in store 'storeXYZ' owned by 'user456'.
     *    get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == 'user456' && request.auth.uid == 'user123'
     * @principle Inherits ownership from the parent store.
     */
    match /stores/{storeId}/packages/{packageId} {
      function isStoreOwner(storeId) {
        return get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      }
      allow get, list: if true;
      allow create: if isStoreOwner(storeId);
      allow update: if isStoreOwner(storeId) && resource != null;
      allow delete: if isStoreOwner(storeId) && resource != null;
    }

    /**
     * @description Manages order data. Validates user and store IDs on create; other operations are not restricted.
     * @path /orders/{orderId}
     * @allow (create) - User with ID 'user123' creating an order with userId 'user123'.
     *    request.resource.data.userId == 'user123'
     * @allow (get, list) - Any user can read order data.
     * @allow (update, delete) - No specific authorization.
     * @deny (create) - User with ID 'user123' creating an order with userId 'user456'.
     *    request.resource.data.userId == 'user456' && request.auth.uid == 'user123'
     * @principle Validates relational integrity between documents.
     */
    match /orders/{orderId} {
      allow get, list: if true;
      allow create: if request.resource.data.userId == request.auth.uid;
      allow update: if true;
      allow delete: if true;
    }

     /**
      * @description Manages voice-only order data. Allows any read and write operations.
      * @path /voice-orders/{voiceOrderId}
      * @allow (get, list, create, update, delete) - Any authenticated user can perform any operation.
      *    request.auth != null
      * @principle Open access for prototyping.
      */
     match /voice-orders/{voiceOrderId} {
          allow get, list: if true;
          allow create: if true;
          allow update: if true;
          allow delete: if true;
     }

    /**
     * @description Manages order item data for each order.
     * @path /orders/{orderId}/orderItems/{orderItemId}
     * @allow (create) - User creating an order item.
     *    true
     * @allow (get, list) - Any user can read order item data.
     * @allow (update, delete) - No specific authorization.
     *    true
     * @principle No ownership enforced.
     */
    match /orders/{orderId}/orderItems/{orderItemId} {
      allow get, list: if true;
      allow create: if true;
      allow update: if true;
      allow delete: if true;
    }

    /**
     * @description Manages product recommendations for each user. Only the user can read or write their own recommendations.
     * @path /users/{userId}/productRecommendations/{productRecommendationId}
     * @allow (create) - User with ID 'user123' creating a recommendation for themselves.
     *    request.resource.data.userId == 'user123'
     * @allow (get, list) - User with ID 'user123' listing their own recommendations.
     *    request.auth.uid == 'user123'
     * @allow (update, delete) - User updating/deleting their own recommendation.
     *    resource.data.userId == 'user123' && request.auth.uid == 'user123'
     * @deny (create) - User with ID 'user123' creating a recommendation for user 'user456'.
     *    request.resource.data.userId == 'user456' && request.auth.uid == 'user123'
     * @deny (get, list) - User with ID 'user123' listing recommendations for user 'user456'.
     *    request.auth.uid == 'user123'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/productRecommendations/{productRecommendationId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if request.resource.data.userId == request.auth.uid;
      allow update: if isOwner(resource.data.userId) && resource != null;
      allow delete: if isOwner(resource.data.userId) && resource != null;
    }

    /**
     * @description Manages cached recipe data. Anyone can read cached recipes.
     * @path /cachedRecipes/{recipeId}
     * @allow (get, list) - Any user can read cached recipe data.
     * @allow (create, update, delete) - No one can write cached recipe data.
     * @principle Public read access.
     */
    match /cachedRecipes/{recipeId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages delivery partner data. Only the delivery partner can read or write their own data.
     * @path /deliveryPartners/{partnerId}
     * @allow (create) - User with ID 'user123' creating their own delivery partner profile, matching the document ID.
     *    request.auth.uid == 'user123' && request.resource.data.userId == 'user123'
     * @allow (get, update, delete) - User with ID 'user123' reading, updating, or deleting their own delivery partner profile (userId matches).
     *    request.auth.uid == 'user123'
     * @deny (create) - User with ID 'user123' creating a delivery partner profile for 'user456'.
     *    request.auth.uid == 'user123' && request.resource.data.userId == 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /deliveryPartners/{partnerId} {
      function isOwner(partnerId) {
        return request.auth.uid == partnerId;
      }
      allow get: if isOwner(partnerId);
      allow list: if false; // No listing of delivery partners.
      allow create: if isOwner(partnerId) && request.resource.data.userId == request.auth.uid;
      allow update: if isOwner(partnerId) && resource != null;
      allow delete: if isOwner(partnerId) && resource != null;
    }

    /**
     * @description Manages payout requests for delivery partners. Only the delivery partner can create, update, or delete their own payout requests.
     * @path /deliveryPartners/{partnerId}/payouts/{payoutId}
     * @allow (create) - User with ID 'user123' creating a payout request for their partner ID.
     *    request.auth.uid == 'user123'
     * @allow (get, list) - User with ID 'user123' listing their own payout requests.
     *    request.auth.uid == 'user123'
     * @allow (update, delete) - User with ID 'user123' updating/deleting their own payout request.
     *    resource.data.partnerId == 'user123' && request.auth.uid == 'user123'
     * @deny (create) - User with ID 'user123' creating a payout request for partner ID 'user456'.
     *    request.auth.uid == 'user123'
     * @principle Enforces document ownership for writes.
     */
    match /deliveryPartners/{partnerId}/payouts/{payoutId} {
      function isOwner(partnerId) {
        return request.auth.uid == partnerId;
      }
      allow get: if isOwner(partnerId);
      allow list: if isOwner(partnerId);
      allow create: if isOwner(partnerId);
      allow update: if isOwner(resource.data.partnerId) && resource != null;
      allow delete: if isOwner(resource.data.partnerId) && resource != null;
    }
  }
}