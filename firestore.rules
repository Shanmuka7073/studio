/**
 * @fileoverview Firestore Security Rules for LocalBasket.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles and store data.
 * Orders have a separate access control mechanism that needs to be defined.
 *
 * Data Structure:
 * - /users/{userId}: User profile data, accessible only by the user themselves.
 * - /stores/{storeId}: Store data, accessible only by the store owner.
 * - /stores/{storeId}/products/{productId}: Products listed by a store, access controlled by store ownership.
 * - /stores/{storeId}/packages/{packageId}: Monthly packages offered by a store, access controlled by store ownership.
 * - /orders/{orderId}: Order information, needs specific access rules defined.
 * - /voice-orders/{voiceOrderId}: Voice orders, needs specific access rules defined.
 * - /orders/{orderId}/orderItems/{orderItemId}: Order items, access controlled by the parent order.
 * - /users/{userId}/productRecommendations/{productRecommendationId}: Product recommendations for users, accessible only by the user themselves.
 * - /cachedRecipes/{recipeId}: Cached recipe data, publicly readable but restricted writes.
 *
 * Key Security Decisions:
 * - Users can only access their own profile data.
 * - Stores can only be created, updated, and deleted by their owners.
 * - Listing of users is disallowed.
 * - Orders: Need specific write access based on roles and order status.
 * - Voice Orders: Open access for delivery partners to fulfill voice-only orders.
 * - Cached Recipes: Publicly readable, but only writable under specific conditions (e.g., by a trusted function).
 *
 * Denormalization for Authorization:
 * - Orders include 'userId' and 'storeId' to simplify authorization checks.
 * - OrderItems include 'orderId' to simplify authorization checks.
 * - ProductRecommendations include 'userId' to simplify authorization checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource and the resource exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Allows only authenticated users to perform operations.
     */
    function isAuthenticated() {
        return request.auth != null;
    }

    /**
     * @description Stores user profile data. Accessible only by the user themselves.
     * @path /users/{userId}
     * @allow (create) - User with UID 'user123' can create their profile at /users/user123.
     * @allow (get) - User with UID 'user123' can read their profile at /users/user123.
     * @deny (update) - User with UID 'user456' cannot update user123's profile.
     * @deny (delete) - User with UID 'user456' cannot delete user123's profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Stores data related to each store.
     * @path /stores/{storeId}
     * @allow (create) - User with UID 'user123' can create a store with ownerId 'user123'.
     * @allow (get) - Anyone can read store data.
     * @deny (update) - User with UID 'user456' cannot update a store owned by 'user123'.
     * @deny (delete) - User with UID 'user456' cannot delete a store owned by 'user123'.
     * @principle Enforces document ownership for writes, public read access.
     */
    match /stores/{storeId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Stores product information as a subcollection of a store.
     * @path /stores/{storeId}/products/{productId}
     * @allow (create) - User with UID 'user123' can create a product under their store.
     * @allow (get) - Anyone can read product data.
     * @deny (update) - User with UID 'user456' cannot update a product in store owned by 'user123'.
     * @deny (delete) - User with UID 'user456' cannot delete a product in store owned by 'user123'.
     * @principle Enforces store ownership for product writes, public read access.
     */
    match /stores/{storeId}/products/{productId} {
      allow get, list: if true;
      allow create: if get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      allow update: if get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      allow delete: if get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Stores monthly package deals for a specific store.
     * @path /stores/{storeId}/packages/{packageId}
     * @allow (create) - User with UID 'user123' can create a package under their store.
     * @allow (get) - Anyone can read package data.
     * @deny (update) - User with UID 'user456' cannot update a package in store owned by 'user123'.
     * @deny (delete) - User with UID 'user456' cannot delete a package in store owned by 'user123'.
     * @principle Enforces store ownership for package writes, public read access.
     */
    match /stores/{storeId}/packages/{packageId} {
      allow get, list: if true;
      allow create: if get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      allow update: if get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      allow delete: if get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
    }

    /**
     * @description Stores order information. Includes denormalized 'userId' and 'storeId' for querying and security rules.
     * @path /orders/{orderId}
     * @allow (create) - Authenticated user can create an order.
     * @allow (get) - Anyone can read order data.
     * @deny (update) - Only the user who created the order can update it.
     * @deny (delete) - Only the user who created the order can delete it.
     * @principle Enforces user-based access control.
     */
    match /orders/{orderId} {
      allow get, list: if true;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if request.auth.uid == resource.data.userId; // TODO: Add more granular access control based on order status and user roles.
      allow delete: if request.auth.uid == resource.data.userId; // TODO: Add more granular access control based on order status and user roles.
    }

    /**
     * @description Stores voice-only orders. Accessible by delivery partners for fulfillment.
     * @path /voice-orders/{voiceOrderId}
     * @allow (create) - Authenticated user can create a voice order.
     * @allow (get) - Anyone can read voice order data.
     * @deny (update) - Only the user who created the voice order can update it.
     * @deny (delete) - Only the user who created the voice order can delete it.
     */
    match /voice-orders/{voiceOrderId} {
      allow get, list: if true;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if request.auth.uid == resource.data.userId; // TODO: Define who can update voice order status (e.g., delivery partners).
      allow delete: if request.auth.uid == resource.data.userId;
    }

    /**
     * @description Stores order item information for each order. Includes denormalized 'orderId' for authorization independence.
     * @path /orders/{orderId}/orderItems/{orderItemId}
     * @allow (create) - Only users with write access to the parent order can create order items.
     * @allow (get) - Anyone can read order item data.
     * @deny (update) - Only users with write access to the parent order can update order items.
     * @deny (delete) - Only users with write access to the parent order can delete order items.
     * @principle Enforces order-based access control for order items.
     */
    match /orders/{orderId}/orderItems/{orderItemId} {
      allow get, list: if true;
      allow create: if get(/databases/$(database)/documents/orders/$(orderId)).data.userId == request.auth.uid;
      allow update: if get(/databases/$(database)/documents/orders/$(orderId)).data.userId == request.auth.uid;
      allow delete: if get(/databases/$(database)/documents/orders/$(orderId)).data.userId == request.auth.uid;
    }

    /**
     * @description Stores product recommendations for each user. Includes denormalized 'userId' for authorization independence.
     * @path /users/{userId}/productRecommendations/{productRecommendationId}
     * @allow (create) - Only the application itself (via a trusted environment) should create recommendations.
     * @allow (get) - The user can read their own product recommendations.
     * @deny (update) - Users cannot update product recommendations.
     * @deny (delete) - Users cannot delete product recommendations.
     * @principle Restricts access to user's own data, read-only for the client.
     */
    match /users/{userId}/productRecommendations/{productRecommendationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if false; // TODO: Only allow create from a trusted environment (e.g., Cloud Functions).
      allow update: if false;
      allow delete: if false;
    }

     /**
      * @description Stores cached recipe ingredients to reduce AI usage.
      * @path /cachedRecipes/{recipeId}
      * @allow (create) - Only the application itself can create cached recipes.
      * @allow (get) - Anyone can read the cached recipes.
      * @deny (update) - No one can update cached recipes.
      * @deny (delete) - No one can delete cached recipes.
      * @principle Limits write access to trusted environments, public read access.
      */
    match /cachedRecipes/{recipeId} {
      allow get, list: if true;
      allow create: if false; // TODO: Restrict create access to a trusted environment (e.g., Cloud Functions).
      allow update: if false;
      allow delete: if false;
    }
  }
}