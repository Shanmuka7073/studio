/**
 * @file Firestore Security Rules for LocalBasket
 * @description This ruleset enforces a strict user-ownership model for user data and store data,
 * with some public read access for product and store listings.
 *
 * Data Structure:
 * - /users/{userId}: User profile data, accessible only by the user themselves.
 * - /stores/{storeId}: Store data, accessible for reading by anyone, but create/update/delete
 *   restricted to the store owner.
 * - /stores/{storeId}/products/{productId}: Product data, accessible for reading by anyone,
 *   but create/update/delete restricted to the store owner.
 * - /orders/{orderId}: Order data, accessible for reading by anyone.
 * - /voice-orders/{voiceOrderId}: Voice order data, accessible for reading by anyone.
 * - /orders/{orderId}/orderItems/{orderItemId}: Order item data, accessible for reading by anyone.
 * - /users/{userId}/productRecommendations/{productRecommendationId}: Product recommendations,
 *   accessible only by the user themselves.
 * - /cachedRecipes/{recipeId}: Cached recipe data, publicly readable.
 * - /deliveryPartners/{partnerId}: Delivery partner data, accessible only by the partner themselves.
 * - /deliveryPartners/{partnerId}/payouts/{payoutId}: Payout data, accessible only by the partner themselves.
 *
 * Key Security Decisions:
 * - Disallows user listing.
 * - Applies ownership-based access control for stores and products.
 * - Orders and Voice Orders are publicly readable.
 * - Publicly readable cached recipes.
 * - Delivery partner data and payouts are only accessible by the partner themselves.
 *
 * Denormalization for Authorization:
 * - The 'Store' entity has an 'ownerId' field, enabling simple ownership checks.
 * - The 'Product' entity has a 'storeId' field, relating it to the parent 'Store'.
 * - The 'Order' entity has 'userId' and 'storeId', though these are not used for access control currently.
 * - The 'DeliveryPartner' entity uses the userId as the document ID.
 *
 * Structural Segregation:
 * - Public and private data are separated using top-level collections for public data (e.g., 'stores', 'orders')
 *   and user subcollections for private data (e.g., '/users/{userId}/productRecommendations').
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @principle Ensures that only authenticated users can perform certain actions.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided user ID.
     * @principle Enforces that a user can only access their own data.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document.
     * @principle Combines ownership check with document existence check for updates and deletes.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for user documents.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their own profile.
     *   Request: { "auth": { "uid": "user123" }, "resource.data.id": "user123" }
     * @allow (get, update, delete) User with UID 'user123' can read, update, and delete their own profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) User with UID 'user123' cannot create a profile for another user.
     *   Request: { "auth": { "uid": "user123" }, "resource.data.id": "user456" }
     * @deny (get, update, delete) User with UID 'user123' cannot read, update, or delete another user's profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @principle Enforces user-ownership: only the authenticated user can manage their own profile.
     */
    match /users/{userId} {
      allow get, update, delete: if isExistingOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId; // Require matching ID on create
      allow list: if false;
    }

    /**
     * @description Rules for store documents.
     * @path /stores/{storeId}
     * @allow (get, list) Any user can read store information.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (create) User with UID 'user123' can create a store with ownerId 'user123'.
     *   Request: { "auth": { "uid": "user123" }, "resource.data.ownerId": "user123" }
     * @allow (update, delete) User with UID 'user123' can update/delete a store they own (ownerId is 'user123').
     *   Request: { "auth": { "uid": "user123" }, "resource.data.ownerId": "user123" }
     * @deny (create) User with UID 'user123' cannot create a store with ownerId 'user456'.
     *   Request: { "auth": { "uid": "user123" }, "resource.data.ownerId": "user456" }
     * @deny (update, delete) User with UID 'user123' cannot update/delete a store they don't own (ownerId is 'user456').
     *   Request: { "auth": { "uid": "user123" }, "resource.data.ownerId": "user456" }
     * @principle Allows public read access while restricting write access to the store owner.
     */
    match /stores/{storeId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Rules for product documents within a store.
     * @path /stores/{storeId}/products/{productId}
     * @allow (get, list) Any user can read product information.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (create) User with UID 'user123' can create a product if they own the store (store.ownerId == 'user123').
     *   Request: { "auth": { "uid": "user123" } } (Assuming store.ownerId == 'user123')
     * @allow (update, delete) User with UID 'user123' can update/delete a product if they own the store (store.ownerId == 'user123').
     *   Request: { "auth": { "uid": "user123" } } (Assuming store.ownerId == 'user123')
     * @deny (create) User with UID 'user123' cannot create a product if they don't own the store (store.ownerId == 'user456').
     *   Request: { "auth": { "uid": "user123" } } (Assuming store.ownerId == 'user456')
     * @deny (update, delete) User with UID 'user123' cannot update/delete a product if they don't own the store (store.ownerId == 'user456').
     *   Request: { "auth": { "uid": "user123" } } (Assuming store.ownerId == 'user456')
     * @principle Allows public read access while restricting write access to the store owner.
     */
    match /stores/{storeId}/products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      allow update, delete: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid && resource != null;
    }

    /**
     * @description Rules for monthly package documents within a store.
     * @path /stores/{storeId}/packages/{packageId}
     * @allow (get, list) Any user can read monthly package information.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (create) User with UID 'user123' can create a package if they own the store (store.ownerId == 'user123').
     *   Request: { "auth": { "uid": "user123" } } (Assuming store.ownerId == 'user123')
     * @allow (update, delete) User with UID 'user123' can update/delete a package if they own the store (store.ownerId == 'user123').
     *   Request: { "auth": { "uid": "user123" } } (Assuming store.ownerId == 'user123')
     * @deny (create) User with UID 'user123' cannot create a package if they don't own the store (store.ownerId == 'user456').
     *   Request: { "auth": { "uid": "user123" } } (Assuming store.ownerId == 'user456')
     * @deny (update, delete) User with UID 'user123' cannot update/delete a package if they don't own the store (store.ownerId == 'user456').
     *   Request: { "auth": { "uid": "user123" } } (Assuming store.ownerId == 'user456')
     * @principle Allows public read access while restricting write access to the store owner.
     */
    match /stores/{storeId}/packages/{packageId} {
      allow get, list: if true;
      allow create: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      allow update, delete: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid && resource != null;
    }

    /**
     * @description Rules for order documents.
     * @path /orders/{orderId}
     * @allow (get, list) Any user can read order information.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create, update, delete) No user can create, update, or delete order information.
     *   Request: { "auth": { "uid": "user123" } }
     */
    match /orders/{orderId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add order management roles/logic if needed
    }

    /**
     * @description Rules for voice order documents.
     * @path /voice-orders/{voiceOrderId}
     * @allow (get, list) Any user can read voice order information.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create, update, delete) No user can create, update, or delete voice order information.
     */
    match /voice-orders/{voiceOrderId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add voice order creation logic if needed.
    }

    /**
     * @description Rules for order item documents within an order.
     * @path /orders/{orderId}/orderItems/{orderItemId}
     * @allow (get, list) Any user can read order item information.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create, update, delete) No user can create, update, or delete order item information.
     */
    match /orders/{orderId}/orderItems/{orderItemId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add order item management logic if needed
    }

    /**
     * @description Rules for product recommendation documents within a user.
     * @path /users/{userId}/productRecommendations/{productRecommendationId}
     * @allow (get, update, delete) User with UID 'user123' can read, update, and delete their own product recommendations.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (create) User with UID 'user123' can create a product recommendation for themselves.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (get, update, delete) User with UID 'user123' cannot read, update, or delete another user's product recommendations.
     *   Request: { "auth": { "uid": "user456" } }
     * @principle Enforces user-ownership: only the authenticated user can manage their own product recommendations.
     */
    match /users/{userId}/productRecommendations/{productRecommendationId} {
      allow get, update, delete: if isExistingOwner(userId);
      allow create: if isOwner(userId);
      allow list: if isOwner(userId);
    }

    /**
     * @description Rules for cached recipe documents.
     * @path /cachedRecipes/{recipeId}
     * @allow (get, list) Any user can read cached recipe information.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create, update, delete) No user can create, update, or delete cached recipe information.
     */
    match /cachedRecipes/{recipeId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role or function for managing cached recipes.
    }

    /**
     * @description Rules for delivery partner documents.
     * @path /deliveryPartners/{partnerId}
     * @allow (get, update, delete) Delivery partner can read, update, and delete their own profile.
     * @allow (create) Delivery partner can create their own profile.
     * @deny (get, update, delete) User with UID 'user123' cannot read, update, or delete another delivery partner's profile.
     * @principle Enforces user-ownership: only the authenticated delivery partner can manage their own profile.
     */
    match /deliveryPartners/{partnerId} {
      allow get, update, delete: if isExistingOwner(partnerId);
      allow create: if isOwner(partnerId) && request.resource.data.userId == partnerId;
      allow list: if false;
    }

    /**
     * @description Rules for payout documents within a delivery partner.
     * @path /deliveryPartners/{partnerId}/payouts/{payoutId}
     * @allow (get, update, delete) Delivery partner can read, update, and delete their own payout requests.
     * @allow (create) Delivery partner can create their own payout requests.
     * @deny (get, update, delete) User with UID 'user123' cannot read, update, or delete another delivery partner's payout requests.
     * @principle Enforces user-ownership: only the authenticated delivery partner can manage their own payout requests.
     */
    match /deliveryPartners/{partnerId}/payouts/{payoutId} {
      allow get, update, delete: if isExistingOwner(partnerId);
      allow create: if isOwner(partnerId);
      allow list: if isOwner(partnerId);
    }
  }
}