/**
 * @file Firestore Security Rules for LocalBasket.
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model where
 * users can only access their own data, while stores can manage their own
 * products and packages. Orders are generally accessible, but order details
 * (orderItems) are restricted. Delivery partner data is also restricted and can
 * be read by authorized users.
 *
 * @data_structure The Firestore data is organized as follows:
 * - /users/{userId}: User profile information (owner-only access).
 * - /stores/{storeId}: Store data (no specific access control defined).
 * - /stores/{storeId}/products/{productId}: Product data for a store (no specific access control defined).
 * - /stores/{storeId}/packages/{packageId}: Monthly package deals for stores (no specific access control defined).
 * - /orders/{orderId}: Order information (general access, needs review).
 * - /voice-orders/{voiceOrderId}: Voice-only orders (no specific access control defined).
 * - /orders/{orderId}/orderItems/{orderItemId}: Items within an order (no specific access control defined).
 * - /users/{userId}/productRecommendations/{productRecommendationId}: Product recommendations for users (owner-only access).
 * - /cachedRecipes/{recipeId}: Cached recipes (no specific access control defined).
 * - /deliveryPartners/{partnerId}: Delivery partner data (owner-only access).
 * - /deliveryPartners/{partnerId}/payouts/{payoutId}: Payout requests for delivery partners (owner-only access).
 *
 * @key_security_decisions
 * - User listing is disallowed to protect privacy.
 * - Data shape validation is relaxed to allow for rapid prototyping.
 * - Default security posture is strict; any ambiguous relationships are denied.
 * - Read access to `/orders` is currently open (`allow list: if true;`) and should be reviewed in production.
 *
 * @denormalization_for_authorization
 * - The 'Order' entity includes 'userId' and 'storeId' fields to simplify
 *   authorization rules without requiring additional reads.
 * - The 'OrderItem' entity includes 'orderId' to make order item authorization independent.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data. Only the user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create, update, get, list) User with ID 'user123' can create/update/get their profile at /users/user123.
     * @deny (create, update, get, list) User with ID 'user456' cannot access profile data at /users/user123.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, validates relational integrity between documents.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId) && resource != null;
      }

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.get("id", "") == userId;
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow update: if isExistingOwner(userId) && request.resource.data.get("id", "") == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to store data.
     * @path /stores/{storeId}
     * @allow (get, list) Anyone can read store data.
     * @allow (create, update, delete) No authorization is implemented in this prototyping stage.
     * @deny (create, update, delete) Nobody can write store data currently.
     * @principle Allows public read access but restricts write access to authorized users (not yet implemented).
     */
    match /stores/{storeId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add store ownership validation (e.g., isOwner(resource.data.ownerId))
    }

    /**
     * @description Controls access to product data within a store.
     * @path /stores/{storeId}/products/{productId}
     * @allow (get, list) Anyone can read product data.
     * @allow (create, update, delete) No authorization is implemented in this prototyping stage.
     * @deny (create, update, delete) Nobody can write product data currently.
     * @principle Allows public read access but restricts write access to store owners (not yet implemented).
     */
    match /stores/{storeId}/products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add store ownership validation (e.g., isOwner(getParentDocument(storeId).data.ownerId))
    }

    /**
     * @description Controls access to monthly package deals within a store.
     * @path /stores/{storeId}/packages/{packageId}
     * @allow (get, list) Anyone can read package data.
     * @allow (create, update, delete) No authorization is implemented in this prototyping stage.
     * @deny (create, update, delete) Nobody can write package data currently.
     * @principle Allows public read access but restricts write access to store owners (not yet implemented).
     */
    match /stores/{storeId}/packages/{packageId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add store ownership validation (e.g., isOwner(getParentDocument(storeId).data.ownerId))
    }

    /**
     * @description Controls access to order data.
     * @path /orders/{orderId}
     * @allow (get, list) Anyone can read order data.
     * @allow (create, update, delete) No authorization is implemented in this prototyping stage.
     * @deny (create, update, delete) Nobody can write order data currently.
     * @principle Allows public read access but restricts write access to authorized users (not yet implemented).
     */
    match /orders/{orderId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add order-specific authorization.
    }

    /**
     * @description Controls access to voice-only order data.
     * @path /voice-orders/{voiceOrderId}
     * @allow (get, list) Anyone can read voice order data.
     * @allow (create, update, delete) No authorization is implemented in this prototyping stage.
     * @deny (create, update, delete) Nobody can write voice order data currently.
     */
    match /voice-orders/{voiceOrderId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add voice order-specific authorization.
    }

    /**
     * @description Controls access to order item data within an order.
     * @path /orders/{orderId}/orderItems/{orderItemId}
     * @allow (get, list) Anyone can read order item data.
     * @allow (create, update, delete) No authorization is implemented in this prototyping stage.
     * @deny (create, update, delete) Nobody can write order item data currently.
     */
    match /orders/{orderId}/orderItems/{orderItemId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add order item-specific authorization.
    }

    /**
     * @description Controls access to product recommendation data for a user.
     * @path /users/{userId}/productRecommendations/{productRecommendationId}
     * @allow (create, update, get, list) User with ID 'user123' can create/update/get their recommendations at /users/user123/productRecommendations/recommendation456.
     * @deny (create, update, get, list) User with ID 'user456' cannot access recommendation data at /users/user123/productRecommendations/recommendation456.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, validates relational integrity between documents.
     */
    match /users/{userId}/productRecommendations/{productRecommendationId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId) && resource != null;
      }

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.get("userId", "") == userId;
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow update: if isExistingOwner(userId) && request.resource.data.get("userId", "") == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to cached recipe data.
     * @path /cachedRecipes/{recipeId}
     * @allow (get, list) Anyone can read cached recipe data.
     * @allow (create, update, delete) No authorization is implemented in this prototyping stage.
     * @deny (create, update, delete) Nobody can write cached recipe data currently.
     */
    match /cachedRecipes/{recipeId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add authorization for managing cached recipes (e.g., admin role).
    }

    /**
     * @description Controls access to delivery partner data.
     * @path /deliveryPartners/{partnerId}
     * @allow (create, update, get, list) User with ID 'partner123' can create/update/get their delivery partner data at /deliveryPartners/partner123.
     * @deny (create, update, get, list) User with ID 'user456' cannot access delivery partner data at /deliveryPartners/partner123.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, validates relational integrity between documents.
     */
     match /deliveryPartners/{partnerId} {
        function isSignedIn() {
          return request.auth != null;
        }
        function isOwner(partnerId) {
          return request.auth.uid == partnerId;
        }
        function isExistingOwner(partnerId) {
          return isSignedIn() && isOwner(partnerId) && resource != null;
        }

        allow create: if isSignedIn() && isOwner(partnerId) && request.resource.data.get("partnerId", "") == partnerId;
        allow get: if isSignedIn() && isOwner(partnerId);
        allow list: if false;
        allow update: if isExistingOwner(partnerId) && request.resource.data.get("partnerId", "") == partnerId;
        allow delete: if isExistingOwner(partnerId);
    }

    /**
     * @description Controls access to payout requests for a delivery partner.
     * @path /deliveryPartners/{partnerId}/payouts/{payoutId}
     * @allow (create, update, get, list) Delivery partner with ID 'partner123' can create/update/get their payout requests at /deliveryPartners/partner123/payouts/payout456.
     * @deny (create, update, get, list) User with ID 'user456' cannot access payout data at /deliveryPartners/partner123/payouts/payout456.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, validates relational integrity between documents.
     */
    match /deliveryPartners/{partnerId}/payouts/{payoutId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(partnerId) {
        return request.auth.uid == partnerId;
      }
      function isExistingOwner(partnerId) {
        return isSignedIn() && isOwner(partnerId) && resource != null;
      }

      allow create: if isSignedIn() && isOwner(partnerId) && request.resource.data.get("partnerId", "") == partnerId; // Partner can request a payout
      allow get: if isSignedIn() && isOwner(partnerId);  // Partner can view their own payout requests
      allow list: if false; // Partner can list their own payout requests
      allow update: if false; // Payouts should not be editable by the partner after creation.  TODO: Implement admin role for payout updates
      allow delete: if false; // Payouts should not be deletable by the partner
    }
  }
}