/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a user-ownership model with public read access for some collections and role-based access for delivery partners.
 *
 * Data Structure:
 * - /users/{userId}: User profile data, accessible only by the user themselves.
 * - /stores/{storeId}: Store data, accessible by anyone. Write access restricted to the store owner.
 * - /stores/{storeId}/products/{productId}: Product data, accessible by anyone. Write access restricted to the store owner.
 * - /stores/{storeId}/packages/{packageId}: Monthly package deals, accessible by anyone. Write access restricted to the store owner.
 * - /orders/{orderId}: Order data, accessible by anyone. Write access restricted to the user who created the order or the assigned delivery partner.
 * - /voice-orders/{voiceOrderId}: Voice order data, accessible by anyone.
 * - /orders/{orderId}/orderItems/{orderItemId}: Order item data, accessible by anyone. Write access restricted to the order owner.
 * - /users/{userId}/productRecommendations/{productRecommendationId}: Product recommendations, accessible only by the user themselves.
 * - /cachedRecipes/{recipeId}: Cached recipes, accessible by anyone.
 * - /deliveryPartners/{partnerId}: Delivery partner data, accessible only by the delivery partner themselves.
 * - /deliveryPartners/{partnerId}/payouts/{payoutId}: Payout requests for delivery partners, accessible only by the delivery partner themselves.
 *
 * Key Security Decisions:
 * - Users can only access their own profile data.
 * - Stores, products, and packages are publicly readable, but only the store owner can modify them.
 * - Orders can be updated either by the user who created them or by the assigned delivery partner.
 * - Product recommendations are private to each user.
 * - Delivery partners can only access their own delivery partner data and payout requests.
 *
 * Denormalization for Authorization:
 * - The `Order` entity includes `userId` and `deliveryPartnerId` to avoid having to query separate collections for authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Grants access only to the user with the matching user ID.
     * @path /users/{userId}
     * @allow (get, update, delete) User A with UID 'user_abc' can read/write their own profile at /users/user_abc.
     * @deny (get, update, delete) User B with UID 'user_xyz' cannot read/write User A's profile at /users/user_abc.
     * @principle Enforces strict user-ownership for profile data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows anyone to read store data, but only the owner can modify it.
     * @path /stores/{storeId}
     * @allow (get, list) Any user can read the store data.
     * @allow (create, update, delete) User A with UID 'user_abc' can create/update/delete a store if they are the owner (store.ownerId == 'user_abc').
     * @deny (create, update, delete) User B with UID 'user_xyz' cannot create/update/delete a store owned by User A.
     * @principle Public read access with owner-only writes.
     */
    match /stores/{storeId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Allows anyone to read product data, but only the store owner can modify it.
     * @path /stores/{storeId}/products/{productId}
     * @allow (get, list) Any user can read the product data.
     * @allow (create, update, delete) User A with UID 'user_abc' can create/update/delete a product if they own the store (get(/stores/storeId).data.ownerId == 'user_abc').
     * @deny (create, update, delete) User B with UID 'user_xyz' cannot create/update/delete a product in a store owned by User A.
     * @principle Public read access with owner-only writes.
     */
    match /stores/{storeId}/products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid && resource != null;
    }

    /**
     * @description Allows anyone to read monthly package data, but only the store owner can modify it.
     * @path /stores/{storeId}/packages/{packageId}
     * @allow (get, list) Any user can read the package data.
     * @allow (create, update, delete) User A with UID 'user_abc' can create/update/delete a package if they own the store (get(/stores/storeId).data.ownerId == 'user_abc').
     * @deny (create, update, delete) User B with UID 'user_xyz' cannot create/update/delete a package in a store owned by User A.
     * @principle Public read access with owner-only writes.
     */
    match /stores/{storeId}/packages/{packageId} {
      allow get, list: if true;
      allow create: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid && resource != null;
    }

    /**
     * @description Allows anyone to read order data.  Write access is allowed either to the user who created the order (userId) or to the deliveryPartnerId.
     * @path /orders/{orderId}
     * @allow (get, list) Any user can read order data.
     * @allow (create) User A with UID 'user_abc' can create an order if request.resource.data.userId == 'user_abc'.
     * @allow (update) User A with UID 'user_abc' can update an order if request.auth.uid == resource.data.userId OR request.auth.uid == resource.data.deliveryPartnerId
     * @allow (delete) User A with UID 'user_abc' can delete an order if they are the owner (resource.data.userId == 'user_abc').
     * @deny (create) User B with UID 'user_xyz' cannot create an order for User A.
     * @deny (update, delete) User B with UID 'user_xyz' cannot update/delete an order owned by User A unless they are the delivery partner.
     * @principle Public read access with owner/delivery partner writes.  Enforces relational integrity on create.
     */
    match /orders/{orderId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      // Allow either the customer or delivery partner to update
      allow update: if isSignedIn() && (
        request.auth.uid == resource.data.userId ||
        request.auth.uid == resource.data.deliveryPartnerId
      ) && resource != null;
      // Only the order owner can delete
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Allows anyone to read voice order data.
     * @path /voice-orders/{voiceOrderId}
     * @allow (get, list) Any user can read voice order data.
     * @principle Public read access.
     */
    match /voice-orders/{voiceOrderId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows anyone to read order item data, but only the order owner can modify it.
     * @path /orders/{orderId}/orderItems/{orderItemId}
     * @allow (get, list) Any user can read the order item data.
     * @allow (create, update, delete) User A with UID 'user_abc' can create/update/delete an order item if they own the order (get(/orders/orderId).data.userId == 'user_abc').
     * @deny (create, update, delete) User B with UID 'user_xyz' cannot create/update/delete an order item in an order owned by User A.
     * @principle Public read access with owner-only writes.
     */
    match /orders/{orderId}/orderItems/{orderItemId} {
      allow get, list: if true;
      allow create: if isSignedIn() && get(/databases/$(database)/documents/orders/$(orderId)).data.userId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/orders/$(orderId)).data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/orders/$(orderId)).data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Grants access only to the user with the matching user ID for product recommendations.
     * @path /users/{userId}/productRecommendations/{productRecommendationId}
     * @allow (get, update, delete) User A with UID 'user_abc' can read/write their own recommendations at /users/user_abc/productRecommendations/{productRecommendationId}.
     * @deny (get, update, delete) User B with UID 'user_xyz' cannot read/write User A's recommendations.
     * @principle Enforces strict user-ownership for product recommendations.
     */
    match /users/{userId}/productRecommendations/{productRecommendationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Allows anyone to read cached recipe data, but no one can modify it.
      * @path /cachedRecipes/{recipeId}
      * @allow (get, list) Any user can read the cached recipe data.
      * @deny (create, update, delete) No one can create, update, or delete cached recipes.
      * @principle Public read access with no writes.
      */
    match /cachedRecipes/{recipeId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Grants access only to the delivery partner with the matching user ID.
     * @path /deliveryPartners/{partnerId}
     * @allow (get, update, delete) Partner A with UID 'partner_abc' can read/write their own profile at /deliveryPartners/partner_abc.
     * @deny (get, update, delete) Partner B with UID 'partner_xyz' cannot read/write Partner A's profile at /deliveryPartners/partner_abc.
     * @principle Enforces strict user-ownership for partner data.
     */
    match /deliveryPartners/{partnerId} {
      allow get: if isOwner(partnerId);
      allow list: if false;
      allow create: if isOwner(partnerId);
      allow update: if isExistingOwner(partnerId);
      allow delete: if isExistingOwner(partnerId);
    }

    /**
     * @description Grants access only to the delivery partner with the matching user ID for payout requests.
     * @path /deliveryPartners/{partnerId}/payouts/{payoutId}
     * @allow (get, list, create) Partner A with UID 'partner_abc' can read/write their own payout requests at /deliveryPartners/partner_abc/payouts/{payoutId}.
     * @deny (get, list, create) Partner B with UID 'partner_xyz' cannot read/write Partner A's payout requests.
     * @principle Enforces strict user-ownership for payout data.
     */
    match /deliveryPartners/{partnerId}/payouts/{payoutId} {
      allow get: if isOwner(partnerId);
      allow list: if isOwner(partnerId);
      allow create: if isOwner(partnerId) && request.resource.data.partnerId == partnerId;
      allow update: if false;
      allow delete: if false;
    }
  }
}