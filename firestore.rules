/**
 * @file Firestore Security Rules for LocalBasket
 * @version Prototyping
 *
 * @Core Philosophy:
 * This ruleset prioritizes strict authorization and owner-based access control. Data schema validation is relaxed to facilitate rapid prototyping.
 *
 * @Data Structure:
 * - /users/{userId}: User profile data, accessible only by the user themselves.
 * - /stores/{storeId}: Store data, writable only by the store owner.
 * - /stores/{storeId}/products/{productId}: Products listed by a specific store, writable only by the store owner.
 * - /stores/{storeId}/packages/{packageId}: Monthly packages offered by a specific store, writable only by the store owner.
 * - /orders/{orderId}: Order data, writable only by the user who created the order.
 * - /voice-orders/{voiceOrderId}: Voice order data, generally open read to delivery partners.
 * - /orders/{orderId}/orderItems/{orderItemId}: Order items for a specific order, writable only by the user who owns the order.
 * - /users/{userId}/productRecommendations/{productRecommendationId}: Product recommendations for a user, writable only by the user themselves.
 * - /cachedRecipes/{recipeId}: Cached recipe ingredients to reduce AI usage. Public read access.
 *
 * @Key Security Decisions:
 * - User listing is disallowed.
 * - Ambiguous relationships default to strict owner-only access.
 * - The rules do not enforce the exact schema of the data being written, only the authorization.
 *
 * @Denormalization for Authorization:
 * - The `Store` entity has an `ownerId` field, which is used to determine ownership for stores and their subcollections.
 * - The `Order` entity has `userId` to identify the user placing the order, and `storeId` to identify the store fulfilled the order.
 *
 * @Structural Segregation:
 * - Private user data is stored under `/users/{userId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to the entire database. This should be removed or secured further.
     * @path /databases/{database}/documents/
     * @allow (list) Any authenticated user can list all documents. This is open and permissive.
     * @deny (create, get, update, delete) All authenticated and unauthenticated users are denied.
     * @principle Restrict overall listing unless specifically needed.
     */
    match /{document=**} {
        allow list: if false;
        allow get: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Manages access to user profile data.
     * @path /users/{userId}
     * @allow (create) Any authenticated user can create their own profile (userId must match auth.uid).
     * @allow (get, list, update, delete) Only the authenticated user (owner) can read, update, or delete their profile.
     * @deny (create) Creation is denied if the userId in the path does not match the authenticated user's ID.
     * @deny (get, list, update, delete) Access is denied for any user other than the owner.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId);
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages access to store data.
     * @path /stores/{storeId}
     * @allow (get, list) Any user can view store information.
     * @allow (create) Only the store owner (ownerId in the document) can create a store.
     * @allow (update, delete) Only the store owner can update or delete store information.
     * @deny (create) Creation is denied if the ownerId in the document does not match the authenticated user's ID.
     * @deny (update, delete) Modification is denied for any user other than the store owner.
     * @principle Enforces document ownership for store data.
     */
    match /stores/{storeId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(storeId) {
        return request.auth.uid == resource.data.ownerId;
      }

       function isCreatingOwner() {
        return request.auth.uid == request.resource.data.ownerId;
      }

      function isExistingOwner(storeId) {
        return isSignedIn() && isOwner(storeId);
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isCreatingOwner();
      allow update: if isExistingOwner(storeId);
      allow delete: if isExistingOwner(storeId);
    }

    /**
     * @description Manages access to product data within a store.
     * @path /stores/{storeId}/products/{productId}
     * @allow (get, list) Any user can view product information.
     * @allow (create) Only the store owner (ownerId in the parent store document) can create a product.
     * @allow (update, delete) Only the store owner can update or delete product information.
     * @deny (create) Creation is denied if the user is not the owner of the parent store.
     * @deny (update, delete) Modification is denied for any user other than the store owner.
     * @principle Enforces document ownership for product data, inheriting ownership from the parent store.
     */
    match /stores/{storeId}/products/{productId} {
       function isSignedIn() {
        return request.auth != null;
      }

      function isStoreOwner(storeId) {
        return get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      }

      function isExistingStoreOwner(storeId) {
        return isSignedIn() && isStoreOwner(storeId);
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isStoreOwner(storeId);
      allow update: if isExistingStoreOwner(storeId);
      allow delete: if isExistingStoreOwner(storeId);
    }

    /**
     * @description Manages access to monthly package data within a store.
     * @path /stores/{storeId}/packages/{packageId}
     * @allow (get, list) Any user can view monthly package information.
     * @allow (create) Only the store owner (ownerId in the parent store document) can create a monthly package.
     * @allow (update, delete) Only the store owner can update or delete monthly package information.
     * @deny (create) Creation is denied if the user is not the owner of the parent store.
     * @deny (update, delete) Modification is denied for any user other than the store owner.
     * @principle Enforces document ownership for monthly package data, inheriting ownership from the parent store.
     */
    match /stores/{storeId}/packages/{packageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isStoreOwner(storeId) {
        return get(/databases/$(database)/documents/stores/$(storeId)).data.ownerId == request.auth.uid;
      }

       function isExistingStoreOwner(storeId) {
        return isSignedIn() && isStoreOwner(storeId);
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isStoreOwner(storeId);
      allow update: if isExistingStoreOwner(storeId);
      allow delete: if isExistingStoreOwner(storeId);
    }

    /**
     * @description Manages access to order data.
     * @path /orders/{orderId}
     * @allow (get) Any authenticated user can retreive a single order.
     * @allow (create) Only an authenticated user can create an order.
     * @allow (list) Only an authenticated user can list orders.
     * @allow (update, delete) Only the user who created the order can update or delete it.
     * @deny (create) Creation is denied if the userId in the document does not match the authenticated user's ID.
     * @deny (update, delete) Modification is denied for any user other than the order creator.
     * @principle Enforces document ownership for order data.
     */
    match /orders/{orderId} {
       function isSignedIn() {
        return request.auth != null;
      }

      function isOrderOwner(orderId) {
        return get(/databases/$(database)/documents/orders/$(orderId)).data.userId == request.auth.uid;
      }

       function isCreatingOrderOwner() {
        return request.auth.uid == request.resource.data.userId;
      }

      function isExistingOrderOwner(orderId) {
        return isSignedIn() && isOrderOwner(orderId);
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn() && isCreatingOrderOwner();
      allow create: if isSignedIn() && isCreatingOrderOwner();
      allow update: if isExistingOrderOwner(orderId);
      allow delete: if isExistingOrderOwner(orderId);
    }

    /**
     * @description Manages access to voice order data.
     * @path /voice-orders/{voiceOrderId}
     * @allow (get, list) Any authenticated user can view voice order information.
     * @allow (create, update, delete) All authenticated users are denied from write operations.
     * @principle Restricts write access to voice orders.
     */
    match /voice-orders/{voiceOrderId} {
      function isSignedIn() {
        return request.auth != null;
      }
        allow get, list: if true;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Manages access to order item data within an order.
     * @path /orders/{orderId}/orderItems/{orderItemId}
     * @allow (get, list) Only the user who created the parent order can read order item information.
     * @allow (create) Only the user who created the parent order can create an order item.
     * @allow (update, delete) Only the user who created the parent order can update or delete order item information.
     * @deny (create) Creation is denied if the user is not the owner of the parent order.
     * @deny (update, delete) Modification is denied for any user other than the order creator.
     * @principle Enforces document ownership for order item data, inheriting ownership from the parent order.
     */
    match /orders/{orderId}/orderItems/{orderItemId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOrderOwner(orderId) {
        return get(/databases/$(database)/documents/orders/$(orderId)).data.userId == request.auth.uid;
      }

      function isExistingOrderOwner(orderId) {
        return isSignedIn() && isOrderOwner(orderId);
      }

      allow get: if isSignedIn() && isOrderOwner(orderId);
      allow list: if isSignedIn() && isOrderOwner(orderId);
      allow create: if isSignedIn() && isOrderOwner(orderId);
      allow update: if isExistingOrderOwner(orderId);
      allow delete: if isExistingOrderOwner(orderId);
    }

    /**
     * @description Manages access to product recommendation data for a user.
     * @path /users/{userId}/productRecommendations/{productRecommendationId}
     * @allow (get, list) Only the user can read their own product recommendations.
     * @allow (create, update, delete) Only the user can create, update or delete their own product recommendations.
     * @deny (get, list, create, update, delete) Access is denied for any user other than the owner.
     * @principle Enforces document ownership for product recommendation data.
     */
    match /users/{userId}/productRecommendations/{productRecommendationId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId);
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
     * @description Manages access to cached recipe data.
     * @path /cachedRecipes/{recipeId}
     * @allow (get, list) Any user can view cached recipe information.
     * @allow (create, update, delete) All authenticated users are denied from write operations.
     */
      match /cachedRecipes/{recipeId} {
        allow get, list: if true;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }
  }
}